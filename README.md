# thread 交互式的学习过程
进程线程的理解

进程是拥有资源的基本单位；
线程是CPU调度的基本单位。

我们都知道Java多线程，Java程序是不是运行在JVM中？ 对操作系统来说，JVM是一个进程，
所以说一个进程中就谈不上多进程了。

创建一个线程调用run方法，就是用当前线程去执行一个普通函数而已，根本没有什么新线程创建出来。
调用start方法才能启动线程。

你想创建一个新的线程出来，肯定得有准备工作啊，设置好这个线程的上下文，
比如这个线程的栈（用于函数调用），线程的状态，这个线程的PC(Program Counter）等等一系列信息以后，
这个线程才可以被调度， 一旦被调度，就会执行那个run()方法了。

为什么要有线程池这个东西？
虽然线程是个轻量级的东西， 但是对于互联网应用来说，
如果每个用户的请求都创建一个线程，那会非常得多，服务器也是难于承受，
再说了，众多的线程去竞争CPU，不断切换，也会让CPU调度不堪重负，很多线程将不得不等待。
所以前辈们的思路就是（1）用少量的线程 （2） 让线程保持忙碌。

就是说只创建一定数量的线程，让这些线程去处理所有的任务，
任务执行完了以后，线程并不结束，而是回到线程池中去，等待接受下一个任务。
这些线程可以预先创建，任务来了就不用临时再创建了，立刻开始服务。

预先创建？ 您刚才不是说线程是程序代码的执行吗？
它是个动态的东西，怎么可能预先创建？ 如果真的创建起来了，
就会调用run方法， 马上执行完了， 线程就结束了！

你忘了重要的一点，线程的状态。 
当线程池的线程刚创建时，让他们进入阻塞状态：等待某个任务的到来。 
如果任务来了，那就好办，唤醒其中一个线程，让它拿到任务去执行即可。

看来之前的图我白画了， BlockingQueue听说过没有？ 
没听说过？ 其实很简单，就是一个线程调用它的take()方法取数据时， 
如果这个Queue中没有数据，该线程会阻塞；同样，一个线程调用它的put方法放数据时，如果Queue满了， 也会阻塞。

看来线程池中每个线程的run（）方法中，要设置一个循环，每次都尝试从BlockingQueue中获取任务，
如果Queue是空的，就阻塞等待， 如果有任务来了，就会通知到线程池的某一个线程去处理，
处理完了以后，依然试图从BlockingQueue中获取任务，就这么依次循环下去。
